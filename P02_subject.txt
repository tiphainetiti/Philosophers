Ok tu a desormais toutes les connaissances pour faire philo.
A partir d'ici, si tu le desires, tu peux commencer a travailler solo.
Ce qui suit ne sert qu'a aller plus vite.

La fonction get_time.

elle permet d'obtenir le temps. Elle prends en parametre un struct timeval:
struct timeval	time; (ici j'ai appele la structure time)
Et modifie ses deux champs qui sont respectivement:

struct timeval {

	tv_sec  // temps en seconde depuis une date en 1975 jsplus laquelle
	tv_usec // nombre de micro secondes ecoulees depuis la derniere seconde

} 	timeval;

tu n'as pas besoin de creer la structure, elle est deja dans la bibliotheque.

je te conseille, dans philo de stocker ton temps dans un long, et de 
creer une fonction get_time qui renvoie un long.
Pour ce projet, l'optimisation est importante.

formule -> (long)current.tv_sec * 1000 + current.tv_usec / 1000.

Je te laisse comprendre la formule par toi meme, mais celle ci permet
d'avoir un temps converti enmilli secondes. Un peu la flemme d'expliquer
tu comprendras quand t'y seras tfacon.



Le moniteur.

Pour savoir l'etat de tes philos, si ils sont morts ou si ils ont assez
mange, tu utilisera un moniteur. Met le dans ton main programme.
met un usleep(1000); pour pas qu'il eclate ton PC. l'echelle de temps
d'un ordi est de l'ordre de la micro seconde, donc avec des mili sec
t'es large.

pour le nombre de repas, par ex 5, chaques philos doivent manger 5 fois.



l'exit.

La fonction exit est interdite dans le projet. Tu vas devoir coder une fonction
qui exit tout toi meme. Elle doit gerer les cas ou un malloc a echoue ou
un thread ne s'est pas lance, et doit tout quitter proprement.



Le calcul de temps.

definis dans ta structure une variable long start.
ensuite, avant de faire tes threads, fais start = get_time();
et pour calculer le temps, tu peux maintenant faire:
	current_time = get_time - philo->start;

tips:

-lance tes philos impairs avec une latence de 500usec.
-si ton nombre de philo est impair, defini time_to_think a time_to_eat * 0.9;
-je te conseille de faire une liste chainee circulaire, chaque maillon etant un philo
	contenant son thread et une fourchette.
-pour eviter les deads locks, fais en sorte que les philos pairs prennent la fourchette
	de droite puis de gauche, et inversement.
-chaque philo repose les fourchette dans l'ordre inverse duquel il les as prises.
-pour que ce soit propre j'ai fait en sorte que chacuns de mes maillons pointent sur
	la meme structure avec les ressources qui ont besoins d'etre partages.
-1 mutex pour print, 1 pour eat et 1 mutex stopper la simulation sont suffisants.
	(sans compter les mutexs des fourchettes evidement).
-plus tu as de mutex, plus ton code seras lent.
-Moi, dans MON code, j'ai mis toutes les valeurs des times dans chacuns de mes philo,
	comme ca chaque philo a ses valeurs et donc pas besoin de mutex vu que pas de
	dataraces.

Et voila, tu sais tout !! Tu devrais etre capable de comprendre ce qui est demande desormais.